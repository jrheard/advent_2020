day 7 is starting to finally get interesting / be worth taking notes on

the input looks like this

    light red bags contain 1 bright white bag, 2 muted yellow bags.
    dark orange bags contain 3 bright white bags, 4 muted yellow bags.
    bright white bags contain 1 shiny gold bag.
    muted yellow bags contain 2 shiny gold bags, 9 faded blue bags.
    shiny gold bags contain 1 dark olive bag, 2 vibrant plum bags.
    dark olive bags contain 3 faded blue bags, 4 dotted black bags.
    vibrant plum bags contain 5 faded blue bags, 6 dotted black bags.
    faded blue bags contain no other bags.
    dotted black bags contain no other bags.

the question is about finding out how many colors of bag can eventually contain a shiny gold bag

obvs i'll use a regex or two to parse the input
but the question is - parse it into what?

i'm initially thinking about a two-phase process
first i parse the input into a list of BagRules, where a BagRule looks like

BagRule
    color: str
    # a list of tuples like [(1, 'white'), (2, 'muted yellow')]
    contents: list[tuple[int, str]]

hm actually i think a dict would be better bc i'll be wanting to do fast lookups in that list
so a `bag_rules` dict of {color: contents}

and then i have a function that - does what?
hm

the function would either walk that dict (essentially a tree) from the top down, or from the bottom up
the top-down approach would be easiest but would be the most wasteful from a perf perspective
the bottom-up approach would be a bit more complicated to figure out i think, but should eliminate a lot of unnecessary work
so bottom-up

so, how do i solve this problem by walking the `bag_rules` dict from the bottom up?

i think i want to assemble a set of `colors_known_to_contain_shiny_gold`

TODO - is a dict really the right approach, or would a tree be better?
i guess the tree's root node would be empty, so it's really like a list of trees
anyway

bleh

ok so we walk the dict and find items like

    dark orange bags contain 3 bright white bags, 4 muted yellow bags.
    bright white bags contain 1 shiny gold bag.
    muted yellow bags contain 2 shiny gold bags, 9 faded blue bags.
    shiny gold bags contain 1 dark olive bag, 2 vibrant plum bags.

and then we insert 'bright white' and 'muted yellow' into the `known_to_contain_shiny_gold` set
and then at that point - hm

what if we do something like this

    # first step: initially populate known_to_contain_shiny_gold
    colors_known_to_contain_shiny_gold = set(
        color for color, contents in bag_rules.items()
        if any(bag_name == 'shiny gold' for _, bag_name in contents)
    )

    colors_to_check = set(
        color for color in bag_rules.keys()
        if color not in colors_known_to_contain_shiny_gold and color != 'shiny gold'
    )

and then like

    while colors_to_check:
        something

and what's the something? well actually i think it's look a lot like the initial population of `colors_known_to_contain_shiny_gold`
so that's interesting

so really actually we're constructing, like, two sets?
`colors_known_to_contain_shiny_gold` and `colors_to_scan_for`
and whenever we walk the contents of `bag_rules`, we always skip anything from `colors_known_to_contain_shiny_gold`

maybe i should just start getting into code at this point, starting w the regexes
actually nvm i dont need a regex

ok cool knocked it out
now it's day 10 part 2

    You glance back down at your bag and try to remember why you brought so many
    adapters; there must be more than a trillion valid ways to arrange them!
    Surely, there must be an efficient way to count the arrangements.

    What is the total number of distinct ways you can arrange the adapters to
    connect the charging outlet to your device?

they bold "more than a trillion" - def sounds like there should be some trick to this
i guess i could try solving it naively and go from there?

hm
well now i'm thinking

they give examples like

    (0), 1, 4, 5, 6, 7, 10, 11, 12, 15, 16, 19, (22)
    (0), 1, 4, 5, 6, 7, 10, 12, 15, 16, 19, (22)
    (0), 1, 4, 5, 7, 10, 11, 12, 15, 16, 19, (22)
    (0), 1, 4, 5, 7, 10, 12, 15, 16, 19, (22)
    (0), 1, 4, 6, 7, 10, 11, 12, 15, 16, 19, (22)
    (0), 1, 4, 6, 7, 10, 12, 15, 16, 19, (22)
    (0), 1, 4, 7, 10, 11, 12, 15, 16, 19, (22)
    (0), 1, 4, 7, 10, 12, 15, 16, 19, (22)

im having vague unformed thoughts about starting at the end and working backward
but not yet clear on how to structure that approach

but for instance notice that
    10, 11, 12, 15, 16, 19
    10, 12, 15, 16, 19

is the rightmost set of permutations
hm

so let's say we start at the right and work left
how do we detect that we've reached a point where multiple permutations are possible?

well let's say we're looking at index -1, 19
what are the three elements to the left of 19?
12, 15, 16
only one of those elements is three-or-less away from 19

and so on down the line until we get to 12

what are the three elements to the left of 12?
7, 10, 11
two of those elements are three-or-less away from 12

so the idea so far is that we start with the number 1
and every time we encounter a situation like this, we multiply it by `num_options` (in this example, 2)
and then we walk to the leftmost valid number to continue from (in this example, 10) and keep going

so let's try that

no, too low - came up with 172186884 but that's less than a trillion

here's what i tried:

    def num_available_adapters(adapter_joltages: list[int]) -> int:
        return sum(
            1 for joltage in adapter_joltages[1:4] if adapter_joltages[0] - joltage <= 3
        )


    def part_2() -> int:
        joltages = sorted(load_input(), reverse=True)

        num_permutations = 1

        while joltages != [0]:
            num_available = num_available_adapters(joltages)
            num_permutations *= num_available
            joltages = joltages[num_available:]

        return num_permutations

so why doesn't this give the right answer?

let's try it on the example data

hm
i think i'm jumping too far to the right

i think the right answer is going to be 2**something

hm hm hm

ok let's work through some more examples to find a pattern

1,2,3,4,5,6
1,2,3,4,6

you use the 5 or you dont
    scenario with the 5:

    1,2,3,4,5
    1,2,3,5

    you use the 4 or you dont
        etc

    scenario without the 5:

    1,2,3,4
    1,2,4

    you use the 3 or you dont
        etc

sure looks recursive

so at the point where we're deciding whether or not to use the 5, we have two options
hm
it feels like maybe the answer is 2 ** num_times_we_had_a_choice
no, it's not always a power of 2, 19208 isn't a power of 2

ugh this is kicking my ass
ok let's go back to their examples

(0), 1, 4, 5, 6, 7, 10, 11, 12, 15, 16, 19, (22)
(0), 1, 4, 5, 6, 7, 10, 12, 15, 16, 19, (22)
(0), 1, 4, 5, 7, 10, 11, 12, 15, 16, 19, (22)
(0), 1, 4, 5, 7, 10, 12, 15, 16, 19, (22)
(0), 1, 4, 6, 7, 10, 11, 12, 15, 16, 19, (22)
(0), 1, 4, 6, 7, 10, 12, 15, 16, 19, (22)
(0), 1, 4, 7, 10, 11, 12, 15, 16, 19, (22)
(0), 1, 4, 7, 10, 12, 15, 16, 19, (22)

so they're going left to right, prob doesnt matter either way

first decision point is - you either use the 5 or you dont
using the 5:

    (0), 1, 4, 5, 6, 7, 10, 11, 12, 15, 16, 19, (22)
    (0), 1, 4, 5, 6, 7, 10, 12, 15, 16, 19, (22)
    (0), 1, 4, 5, 7, 10, 11, 12, 15, 16, 19, (22)
    (0), 1, 4, 5, 7, 10, 12, 15, 16, 19, (22)

    you either use the 6 or you dont
    using the 6:

        (0), 1, 4, 5, 6, 7, 10, 11, 12, 15, 16, 19, (22)
        (0), 1, 4, 5, 6, 7, 10, 12, 15, 16, 19, (22)

        you either use the 11 or you dont
        using the 11:
            (0), 1, 4, 5, 6, 7, 10, 11, 12, 15, 16, 19, (22)
        not using the 11:
            (0), 1, 4, 5, 6, 7, 10, 12, 15, 16, 19, (22)

    not using the 6:

        you either use the 11 or you dont
        using the 11:
            (0), 1, 4, 5, 7, 10, 11, 12, 15, 16, 19, (22)
        not using the 11:
            (0), 1, 4, 5, 7, 10, 12, 15, 16, 19, (22)


not using the 5:
    (not expanding this one)

    (0), 1, 4, 6, 7, 10, 11, 12, 15, 16, 19, (22)
    (0), 1, 4, 6, 7, 10, 12, 15, 16, 19, (22)
    (0), 1, 4, 7, 10, 11, 12, 15, 16, 19, (22)
    (0), 1, 4, 7, 10, 12, 15, 16, 19, (22)

hrm hrm hrm
at the end of the day there are three decision points
the 5, the 6, the 11

at the 5 level, there are 4 options + 4 options
at the 6 level, there are 2 options + 2 options
at the 11 level, there are 1 option + 1 option

so i'm like

do we count the number of decision points
and then do like

if num_decision_points == 1:
    return 1

result = 0
for i in range(num_decision_points:)
    result = something

this first example is too small to generalize on, let's use the other one
this one keeps going for ages, has 19208 permutations

(0), 1, 2, 3, 4, 7, 8, 9, 10, 11, 14, 17, 18, 19, 20, 23, 24, 25, 28, 31, 32, 33, 34, 35, 38, 39, 42, 45, 46, 47, 48, 49, (52)
(0), 1, 2, 3, 4, 7, 8, 9, 10, 11, 14, 17, 18, 19, 20, 23, 24, 25, 28, 31, 32, 33, 34, 35, 38, 39, 42, 45, 46, 47, 49, (52)
(0), 1, 2, 3, 4, 7, 8, 9, 10, 11, 14, 17, 18, 19, 20, 23, 24, 25, 28, 31, 32, 33, 34, 35, 38, 39, 42, 45, 46, 48, 49, (52)
(0), 1, 2, 3, 4, 7, 8, 9, 10, 11, 14, 17, 18, 19, 20, 23, 24, 25, 28, 31, 32, 33, 34, 35, 38, 39, 42, 45, 46, 49, (52)
(0), 1, 2, 3, 4, 7, 8, 9, 10, 11, 14, 17, 18, 19, 20, 23, 24, 25, 28, 31, 32, 33, 34, 35, 38, 39, 42, 45, 47, 48, 49, (52)
(0), 3, 4, 7, 10, 11, 14, 17, 20, 23, 25, 28, 31, 34, 35, 38, 39, 42, 45, 46, 48, 49, (52)
(0), 3, 4, 7, 10, 11, 14, 17, 20, 23, 25, 28, 31, 34, 35, 38, 39, 42, 45, 46, 49, (52)
(0), 3, 4, 7, 10, 11, 14, 17, 20, 23, 25, 28, 31, 34, 35, 38, 39, 42, 45, 47, 48, 49, (52)
(0), 3, 4, 7, 10, 11, 14, 17, 20, 23, 25, 28, 31, 34, 35, 38, 39, 42, 45, 47, 49, (52)
(0), 3, 4, 7, 10, 11, 14, 17, 20, 23, 25, 28, 31, 34, 35, 38, 39, 42, 45, 48, 49, (52)

so here's an example of a decision point
2,4,5

and here are some non-examples
2,4,6
2,5

it's a point where adapters[i+2] <= 3
cool so let's write a function that counts the number of decision points

ugh i dunno man
the function says there are 15 decision points in the long example
which matches up my manual mental count just now, assuming my "decision points" definition/approach is reasonable
but so like
what do i do with that?

the right answer is 19208
but 2 ** 14 is 16384

hrm
math is hard

gotta go for the day, if i dont come up with an answer to this one im just gonna look it up and move on;
i wanna get programming practice, not math practice (although it sure would be nice if i could come up w this one myself)

ok so now im doin day 11
implementation is going fine so far, its game of life
but my first pass implementation isn't converging the way they say it should

guess i gotta make a print method

hm
it looks like seats are going from floor to non-floor
which should never happen
how's that happening?

    #.LL.L#.##
    #LLLLLL.L#
    L.L.L..L..
    #LLL.LL.L#
    #.LL.LL.LL
    #.LLLL#.##
    ..L.L.....
    #LLLLLLLL#
    #.LLLLLL.L
    #.#LLLL.##

    ##L###.###
    .L.L...L..
    ########L#
    ##.###.#LL
    .##..#####
    LL.#LL.###
    #L.#L#.###
    ..#....#L.
    #L.LL#.L.#
    ##.#L#.#L#

something wrong with my print method?
if not, where?

hm
it looks like i was doing

    for x in range(0, self.height):
        for y in range(0, self.width):

instead of

    for y in range(0, self.height):
        for x in range(0, self.width):

why should that have made a difference?
because it was causing the resulting seats to be appended to the new grid in the wrong order

ok cool neat
so now i'm working on day 13 part 2

this bus ids and indexes stuff
bit of a weird problem

my initial idea here is to find the bus with the largest ID
i feel like that must have a big influence on the shape of the desired timestamp

let's say the biggest id is 853
and its index is 17
then the timestamp will need to be a multiple of 836 (853 - 17)

is this, like, a factorization problem?

anyway let's see if that bears out by looking at one of their examples

    1789,37,47,1889 first occurs at timestamp 1202161486.

1889 is at index 3
timestamp must be a multiple of 1886 then?

>>> 1202161486 % 1886
568

nope
bleh

>>> 1202161486 % 1889
1886

hm
that's interesting

timestamp must be (a multiple of bus id) - bus_index?

let's try another example

    67,7,x,59,61 first occurs at timestamp 1261476.

biggest id 67 at index 0

>>> 1261476 % 67
0

let's try one where index isn't 0

    The earliest timestamp that matches the list 17,x,13,19 is 3417.

id 19 at index 3

>>> 3417 % 19
16

ok cool so it IS the case that the largest bus id and its index are a constraint on the timestamp
makes sense

so can we say anything about the second-largest? like a general statement about how it influences the timestamp?

    67,7,x,59,61 first occurs at timestamp 1261476.

second-largest is 61 at index 4

>>> 1261476 % 61
57

cool so it looks like that property holds for all bus ids
the timestamp must be (a multiple of the bus id) - bus_index

so uh
how can we use that?

i guess i could generate an infinite list of valid numbers for the largest bus
and then for each number in the list, validate it against the other bus ids

ok so i wrote that but it's pretty slow
not really sure what to do to speed it up, will think about it

ok so let's try this again
the target number has these properties:
for each bus id and index:
    the number is (a multiple of the bus id) - the index

so what if we just assemble that number by hand and see if it's the smallest?
i dont think it'll be the smallest but can't hurt to check

yeah, no dice

def part_2() -> int:
    result = 1
    for index, bus_id in load_indexes_and_bus_ids():
        result = result * bus_id - index

    return result

2245654873698359

aoc says the answer is too high

i think i'm gonna look this one up too

https://0xdf.gitlab.io/adventofcode2020/13
_this_ guy got stuck too, says this is number theory stuff
whee

ok now it's day 17, 3d game of life

    Before any cycles:

    z=0
    .#.
    ..#
    ###


    After 1 cycle:

    z=-1
    #..
    ..#
    .#.

    z=0
    #.#
    .##
    .#.

    z=1
    #..
    ..#
    .#.

i don't understand why in this example, the "after 1 cycle" doesn't have 4 rows at z=0

ugh whyy

oh wait
does it lose a row at thet op???
let's do this by hand

    .#.
    ..#
    ###

    becomes

    ...
    #.#
    .##
    .#.

ok yeah cool
good! ok phew
ok so now i can implement

ok day 18

going back and forth about whether or not i should use some kind of tree data structure

or just a recursive function that evaluates strings
leaning toward the recursive fn

hm
so i feel like the recursive fn wants to evaluate the leftmost thing
whether that's a bare number or a parenthesized expression

hm hm hm
ok so hm
what if i did like two passes
one pass to do the parentheses
and another pass to go left-to-right

hm no hm
this is tricky bc the recursive fn approach makes it so that the equation is evaluated basically right-to-left
which i dont want

ugh tree or not? hm

noodling about a recursive pass followed by a left-to-right pass
hm

ok trying out a tree


    print(parse_expression_string("2 * 3 + (4 * 5)", 0))
    Expression(left=2, right=Expression(left=3,
    right=Expression(left=Expression(left=4, right=Expression(left=5,
    right=None, operator=None, parentheses_depth=1), operator='*',
    parentheses_depth=1), right=None, operator=None, parentheses_depth=0),
    operator='+', parentheses_depth=0), operator='*', parentheses_depth=0)

can i work with this?
maybe

first: find the head of the expression with the greatest nonzero parentheses depth
second: evaluate it in a nonrecursive way, asserting along the way that all .left values are ints
maybe a while loop?

ok cool
so at this point i have a fn for parsing a string into an expression tree
and i have a fn for evaluating a "leaf" expression
now i need a fn that takes an expression and recursively replaces the deepest parenthesized expression with an int
until there are no parenthesized expressions left