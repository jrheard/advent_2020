10/13/23

day 7 is starting to finally get interesting / be worth taking notes on

the input looks like this

    light red bags contain 1 bright white bag, 2 muted yellow bags.
    dark orange bags contain 3 bright white bags, 4 muted yellow bags.
    bright white bags contain 1 shiny gold bag.
    muted yellow bags contain 2 shiny gold bags, 9 faded blue bags.
    shiny gold bags contain 1 dark olive bag, 2 vibrant plum bags.
    dark olive bags contain 3 faded blue bags, 4 dotted black bags.
    vibrant plum bags contain 5 faded blue bags, 6 dotted black bags.
    faded blue bags contain no other bags.
    dotted black bags contain no other bags.

the question is about finding out how many colors of bag can eventually contain a shiny gold bag

obvs i'll use a regex or two to parse the input
but the question is - parse it into what?

i'm initially thinking about a two-phase process
first i parse the input into a list of BagRules, where a BagRule looks like

BagRule
    color: str
    # a list of tuples like [(1, 'white'), (2, 'muted yellow')]
    contents: list[tuple[int, str]]

hm actually i think a dict would be better bc i'll be wanting to do fast lookups in that list
so a `bag_rules` dict of {color: contents}

and then i have a function that - does what?
hm

the function would either walk that dict (essentially a tree) from the top down, or from the bottom up
the top-down approach would be easiest but would be the most wasteful from a perf perspective
the bottom-up approach would be a bit more complicated to figure out i think, but should eliminate a lot of unnecessary work
so bottom-up

so, how do i solve this problem by walking the `bag_rules` dict from the bottom up?

i think i want to assemble a set of `colors_known_to_contain_shiny_gold`

TODO - is a dict really the right approach, or would a tree be better?
i guess the tree's root node would be empty, so it's really like a list of trees
anyway

bleh

ok so we walk the dict and find items like

    dark orange bags contain 3 bright white bags, 4 muted yellow bags.
    bright white bags contain 1 shiny gold bag.
    muted yellow bags contain 2 shiny gold bags, 9 faded blue bags.
    shiny gold bags contain 1 dark olive bag, 2 vibrant plum bags.

and then we insert 'bright white' and 'muted yellow' into the `known_to_contain_shiny_gold` set
and then at that point - hm

what if we do something like this

    # first step: initially populate known_to_contain_shiny_gold
    colors_known_to_contain_shiny_gold = set(
        color for color, contents in bag_rules.items()
        if any(bag_name == 'shiny gold' for _, bag_name in contents)
    )

    colors_to_check = set(
        color for color in bag_rules.keys()
        if color not in colors_known_to_contain_shiny_gold and color != 'shiny gold'
    )

and then like

    while colors_to_check:
        something

and what's the something? well actually i think it's look a lot like the initial population of `colors_known_to_contain_shiny_gold`
so that's interesting

so really actually we're constructing, like, two sets?
`colors_known_to_contain_shiny_gold` and `colors_to_scan_for`
and whenever we walk the contents of `bag_rules`, we always skip anything from `colors_known_to_contain_shiny_gold`

maybe i should just start getting into code at this point, starting w the regexes
actually nvm i dont need a regex

ok cool knocked it out
now it's day 10 part 2

    You glance back down at your bag and try to remember why you brought so many
    adapters; there must be more than a trillion valid ways to arrange them!
    Surely, there must be an efficient way to count the arrangements.

    What is the total number of distinct ways you can arrange the adapters to
    connect the charging outlet to your device?

they bold "more than a trillion" - def sounds like there should be some trick to this
i guess i could try solving it naively and go from there?

hm
well now i'm thinking

they give examples like

    (0), 1, 4, 5, 6, 7, 10, 11, 12, 15, 16, 19, (22)
    (0), 1, 4, 5, 6, 7, 10, 12, 15, 16, 19, (22)
    (0), 1, 4, 5, 7, 10, 11, 12, 15, 16, 19, (22)
    (0), 1, 4, 5, 7, 10, 12, 15, 16, 19, (22)
    (0), 1, 4, 6, 7, 10, 11, 12, 15, 16, 19, (22)
    (0), 1, 4, 6, 7, 10, 12, 15, 16, 19, (22)
    (0), 1, 4, 7, 10, 11, 12, 15, 16, 19, (22)
    (0), 1, 4, 7, 10, 12, 15, 16, 19, (22)

im having vague unformed thoughts about starting at the end and working backward
but not yet clear on how to structure that approach

but for instance notice that
    10, 11, 12, 15, 16, 19
    10, 12, 15, 16, 19

is the rightmost set of permutations
hm

so let's say we start at the right and work left
how do we detect that we've reached a point where multiple permutations are possible?

well let's say we're looking at index -1, 19
what are the three elements to the left of 19?
12, 15, 16
only one of those elements is three-or-less away from 19

and so on down the line until we get to 12

what are the three elements to the left of 12?
7, 10, 11
two of those elements are three-or-less away from 12

so the idea so far is that we start with the number 1
and every time we encounter a situation like this, we multiply it by `num_options` (in this example, 2)
and then we walk to the leftmost valid number to continue from (in this example, 10) and keep going

so let's try that

no, too low - came up with 172186884 but that's less than a trillion

here's what i tried:

    def num_available_adapters(adapter_joltages: list[int]) -> int:
        return sum(
            1 for joltage in adapter_joltages[1:4] if adapter_joltages[0] - joltage <= 3
        )


    def part_2() -> int:
        joltages = sorted(load_input(), reverse=True)

        num_permutations = 1

        while joltages != [0]:
            num_available = num_available_adapters(joltages)
            num_permutations *= num_available
            joltages = joltages[num_available:]

        return num_permutations

so why doesn't this give the right answer?